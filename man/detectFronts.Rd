% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Raster-class.R, R/array-class.R,
%   R/grec-internal.R, R/grec-main.R, R/list-class.R, R/matrix-class.R
\name{detectFronts.RasterLayer}
\alias{detectFronts.RasterLayer}
\alias{detectFronts.array}
\alias{detectFronts.default}
\alias{detectFronts}
\alias{detectFronts.list}
\alias{detectFronts.matrix}
\title{Apply gradient-based methodologies to environmental data}
\usage{
\method{detectFronts}{RasterLayer}(x, method = "BelkinOReilly2009",
  finalSmooth = FALSE, intermediate = FALSE, control = list(), ...)

\method{detectFronts}{array}(x, method = "BelkinOReilly2009",
  intermediate = FALSE, ...)

\method{detectFronts}{default}(x, method = "BelkinOReilly2009",
  intermediate = FALSE, ...)

detectFronts(x, method = "BelkinOReilly2009", intermediate = FALSE, ...)

\method{detectFronts}{list}(x, method = "BelkinOReilly2009",
  intermediate = FALSE, ...)

\method{detectFronts}{matrix}(x, method = "BelkinOReilly2009",
  intermediate = FALSE, ...)
}
\arguments{
\item{x}{Main input of class \code{matrix}, \code{array}, XYZ \code{list} or \code{RasterLayer}. See 'Details.'}

\item{method}{\code{character} string indicating the method that will be used. See 'Details'.}

\item{intermediate}{\code{logical} indicating whether to get the intermediate matrices (\code{TRUE})
or just the final one (\code{FALSE}).}

\item{control}{A \code{list} of control parameters for filter application See 'Details'.}

\item{...}{Extra arguments that will depend on the selected method.}
}
\value{
Depending of input class of \code{x}, the output will preserve its class.
}
\description{
This function takes a environmental map (as a numeric \code{matrix}, \code{array}, XYZ\code{list}
or \code{RasterLayer}) and allows the users to apply methodologies based on gradient-searching.
}
\details{
Version 1.2.x performs one method: Belkin & O'Reilly (2009), following 4 steps:
\enumerate{
\item Smoothing of the original data by applying a Contextual Median Filter.
\item Apply sobel kernel horizontally (sobelH) and vertically (sobelV).
\item Extract gradients using the formula \eqn{sqrt(sobelH^2 + sobelV^2)}.
}

\code{x} could be given as a single numeric matrix from an environmental map. Othersiwe it also can be set as
a three dimensions list 'x', 'y' and 'z' as follows: 'x' (a vector of longitudes), 'y' (vector of latitudes) and
'z' as a matrix of dimensions \code{length(x$x)}x\code{xlength(x$y)}. You can also specify \code{x} as a
\code{RasterLayer} or \code{array} object. If \code{x} is an \code{array}, it must have 3 dimensions: lon, lat
and time. It is not required to specify the \code{dimnames}. The output will preserve all the attributes of input.

Users can change the methodology used for the calculation of gradients by \code{method}. By default it will be
the Belkin & O'Reilly (2009) at v1.2.x.

The control argument is a list that allows the (advanced) users modify some aspects of filter
application. The parameters of \code{control} are given to functions of \code{\link{imagine}} package.
It must be a \code{list} including the following named objects:
\describe{
\item{\strong{firstSmooth}}{Arguments (\code{radius} and \code{times}) pased to \code{\link{medianFilter}}
function, used for apply the smoothing to the original matrix. It must be given as a named list.}
\item{\strong{sobelStrength}}{Number that multiplies \code{qLimits} vector. It is usefull to highlight
the differences.}
\item{\strong{clearNoise}}{Arguments (\code{radius} and \code{times}) pased to \code{\link{medianFilter}}
function, used for apply the median-filter for cleaning noise and getting the output matrix. It must be
given as a named list.}
}
}
\examples{
# Build an example data
# Load example data
data(sst)
exampleSSTData <- list(x = sst$longitude,
                       y = sst$latitude,
                       z = sst$sst[,,1])
# Simple application
out <- detectFronts(x = exampleSSTData)
image(out, col = colPalette)

# qLimits effect
out <- detectFronts(x = exampleSSTData, qLimits = c(0.75, 0.99))
image(out, col = colPalette)

# Simple application
out <- detectFronts(x = exampleSSTData, finalSmooth = TRUE)
image(out, col = colPalette)
}
\references{
Belkin, I. M., & O'Reilly, J. E. (2009). An algorithm for oceanic front detection in chlorophyll
and SST satellite imagery. Journal of Marine Systems, 78(3), 319-326
(\url{http://dx.doi.org/10.1016/j.jmarsys.2008.11.018}).
}
